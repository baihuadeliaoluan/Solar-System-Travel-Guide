<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ç»ˆæå¤ªé˜³ç³»å¯è§†åŒ–ï¼ˆå¢å¼ºç‰ˆï¼šæ›´å¤šå¤©ä½“ï¼‰</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #0A0C15, #05070E);
      font-family: 'Segoe UI', Arial, sans-serif;
      color: white;
      cursor: default;
    }
    canvas {
      display: block;
    }
    #infoPanel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(10, 15, 30, 0.9);
      padding: 15px;
      border-radius: 10px;
      max-width: 350px;
      font-size: 14px;
      line-height: 1.5;
      backdrop-filter: blur(8px);
      display: none;
      z-index: 100;
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
    }
    #infoPanel h3 {
      margin: 0 0 10px 0;
      color: #FFD700;
      text-shadow: 0 0 3px rgba(0,0,0,0.7);
    }
    #infoPanel p {
      margin: 4px 0;
    }
    #scaleNote {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(10, 15, 30, 0.8);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 10;
      border: 1px solid rgba(255,255,255,0.15);
    }
    #title {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      font-size: 22px;
      text-shadow: 0 0 12px rgba(255,255,255,0.9);
      z-index: 10;
      letter-spacing: 1px;
    }
    #instructions {
      position: absolute;
      bottom: 80px;
      left: 20px;
      background: rgba(10, 15, 30, 0.6);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 10;
      border: 1px solid rgba(255,255,255,0.1);
    }
    #pauseBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(10, 15, 30, 0.8);
      color: white;
      border: 1px solid rgba(255,255,255,0.3);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      z-index: 10;
      user-select: none;
      transition: all 0.2s;
    }
    #pauseBtn:hover {
      background: rgba(30, 40, 70, 0.95);
      transform: scale(1.03);
    }
    #toggleBtns {
      position: absolute;
      top: 60px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10;
    }
    .toggleBtn {
      background: rgba(10, 15, 30, 0.8);
      color: white;
      border: 1px solid rgba(255,255,255,0.3);
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    .toggleBtn:hover {
      background: rgba(30, 40, 70, 0.95);
    }
    .toggleBtn.active {
      background: rgba(50, 80, 150, 0.9);
      border-color: rgba(100, 150, 255, 0.5);
    }
  </style>
</head>
<body>
  <div id="title">å¤ªé˜³ç³»æ—…è¡ŒæŒ‡å—ï¼ŒğŸš€æ˜æ—¥å·èˆªç©ºå…¬å¸ï¼Œå€¼å¾—ä¿¡èµ–d(Â´Ï‰ï½€*)</div>
  <canvas id="solarSystem"></canvas>
  <div id="infoPanel"></div>
  <div id="pauseBtn">â¸ï¸ æš‚åœ</div>
  <div id="toggleBtns">
    <button class="toggleBtn active" data-type="dwarfPlanets">æŸ¯ä¼Šä¼¯å¸¦å¤©ä½“</button>
    <button class="toggleBtn active" data-type="asteroidBelt">å°è¡Œæ˜Ÿå¸¦</button>
    <button class="toggleBtn active" data-type="comets">è‘—åå½—æ˜Ÿ</button>
    <button class="toggleBtn active" data-type="probes">å¤ªç©ºæ¢æµ‹å™¨</button>
    <button class="toggleBtn active" data-type="distantObjects">è¿œæ–¹å¤©ä½“</button>
  </div>
  <script>
    const canvas = document.getElementById('solarSystem');
    const ctx = canvas.getContext('2d');
    const infoPanel = document.getElementById('infoPanel');
    const pauseBtn = document.getElementById('pauseBtn');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    // è§†å›¾æ§åˆ¶
    let camX = 0;
    let camY = 0;
    let zoom = 1;
    // è¾“å…¥çŠ¶æ€
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let spacePressed = false;
    let mouseX = 0;
    let mouseY = 0;
    // åŠ¨ç”»çŠ¶æ€
    let isPaused = false;
    // å¤©ä½“æ˜¾ç¤ºå¼€å…³
    const displayOptions = {
      dwarfPlanets: true,
      asteroidBelt: true,
      comets: true,
      probes: true,
      distantObjects: true
    };
    // æ˜Ÿç©ºèƒŒæ™¯
    const stars = [];
    function initStars() {
      // 200é¢—æ˜Ÿæ˜Ÿ
      for (let i = 0; i < 200; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 0.8 + 0.3,
          brightness: Math.random() * 0.25 + 0.1,
          twinkleSpeed: Math.random() * 0.05 + 0.01
        });
      }
    }
    function drawStars() {
      // æ·±ç©ºæ¸å˜èƒŒæ™¯
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#000000');
      gradient.addColorStop(0.5, '#090c16');
      gradient.addColorStop(1, '#0f1525');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // é—ªçƒæ˜Ÿæ˜Ÿ
      stars.forEach(star => {
        star.brightness += Math.sin(Date.now() * star.twinkleSpeed) * 0.02;
        star.brightness = Math.max(0.1, Math.min(0.35, star.brightness));
        ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    // å¯¹æ•°è·ç¦»æ˜ å°„
    function auToVisual(au) {
      const minAU = 0.1;
      const maxAU = 63000;
      const clampedAU = Math.max(au, minAU);
      const logAU = Math.log10(clampedAU);
      const logMin = Math.log10(minAU);
      const logMax = Math.log10(maxAU);
      const ratio = (logAU - logMin) / (logMax - logMin);
      return ratio * 5000;
    }
    function worldToScreen(wx, wy) {
      return {
        x: (wx - camX) * zoom + canvas.width / 2,
        y: (wy - camY) * zoom + canvas.height / 2
      };
    }
    function screenToWorld(sx, sy) {
      return {
        x: (sx - canvas.width / 2) / zoom + camX,
        y: (sy - canvas.height / 2) / zoom + camY
      };
    }
    // å¤©ä½“æ•°æ® - å…«å¤§è¡Œæ˜Ÿ + å†¥ç‹æ˜Ÿ
    const celestialBodies = [
      { name: "å¤ªé˜³", type: "star", distanceAU: 0, diameterKm: 1_392_700, rotationHours: 609, orbitDays: 0, radius: 20, color: "#FDB813" },
      { name: "æ°´æ˜Ÿ", distanceAU: 0.39, diameterKm: 4879, rotationHours: 1407.6, orbitDays: 88, radius: 3.5, color: "#afdfe4" },
      { name: "é‡‘æ˜Ÿ", distanceAU: 0.72, diameterKm: 12104, rotationHours: -5832.5, orbitDays: 225, radius: 5.5, color: "#E7CDCD" },
      { name: "åœ°çƒ", distanceAU: 1, diameterKm: 12756, rotationHours: 24, orbitDays: 365.25, radius: 6, color: "#6B93D6", hasMoon: true },
      { name: "ç«æ˜Ÿ", distanceAU: 1.52, diameterKm: 6792, rotationHours: 24.6, orbitDays: 687, radius: 4.5, color: "#C1440E" },
      { name: "è°·ç¥æ˜Ÿ", type: "dwarf", group: "asteroidBelt", distanceAU: 2.77, diameterKm: 940, rotationHours: 9.1, orbitDays: 1680, radius: 2.2, color: "#D2B48C", info: "å°è¡Œæ˜Ÿå¸¦æœ€å¤§å¤©ä½“ï¼ŒçŸ®è¡Œæ˜Ÿ" },
      { name: "æœ¨æ˜Ÿ", distanceAU: 5.2, diameterKm: 142984, rotationHours: 9.9, orbitDays: 4333, radius: 15, color: "#D8CA9D" },
      { name: "åœŸæ˜Ÿ", distanceAU: 9.5, diameterKm: 120536, rotationHours: 10.7, orbitDays: 10759, radius: 12, color: "#f4a460", hasRings: true },
      { name: "å¤©ç‹æ˜Ÿ", distanceAU: 19.2, diameterKm: 51118, rotationHours: -17.2, orbitDays: 30687, radius: 9, color: "#D1E7E7" },
      { name: "æµ·ç‹æ˜Ÿ", distanceAU: 30.1, diameterKm: 49528, rotationHours: 16.1, orbitDays: 60190, radius: 9, color: "#5B5DDF" },
      { name: "å†¥ç‹æ˜Ÿ", type: "dwarf", group: "dwarfPlanets", distanceAU: 39.5, diameterKm: 2376, rotationHours: 153.3, orbitDays: 90560, radius: 2.5, color: "#A7A7A7", info: "çŸ®è¡Œæ˜Ÿï¼ŒæŸ¯ä¼Šä¼¯å¸¦å¤©ä½“" }
    ];
    // æŸ¯ä¼Šä¼¯å¸¦çŸ®è¡Œæ˜Ÿ
    const dwarfPlanets = [
      { name: "é˜‹ç¥æ˜Ÿ", type: "dwarf", distanceAU: 68, diameterKm: 2326, orbitDays: 204000, radius: 2.3, color: "#E6E6E6", info: "æ¯”å†¥ç‹æ˜Ÿè´¨é‡æ›´å¤§çš„çŸ®è¡Œæ˜Ÿ" },
      { name: "é¸Ÿç¥æ˜Ÿ", type: "dwarf", distanceAU: 45.8, diameterKm: 1430, orbitDays: 112000, radius: 1.8, color: "#F0E68C", info: "æŸ¯ä¼Šä¼¯å¸¦ç¬¬ä¸‰å¤§å·²çŸ¥çŸ®è¡Œæ˜Ÿ" },
      { name: "å¦Šç¥æ˜Ÿ", type: "dwarf", distanceAU: 43, diameterKm: 1960, orbitDays: 103000, radius: 2, color: "#FFFFE0", info: "æ©„æ¦„çƒå½¢çŠ¶ï¼Œå¿«é€Ÿè‡ªè½¬çš„çŸ®è¡Œæ˜Ÿ" },
      { name: "å…±å·¥æ˜Ÿ", type: "dwarf", distanceAU: 67, diameterKm: 1230, orbitDays: 190000, radius: 1.6, color: "#FFB6C1", info: "çº¢è‰²è¡¨é¢ï¼Œæœ‰å«æ˜Ÿç›¸æŸ³" }
    ];
    // å°è¡Œæ˜Ÿå¸¦å¤©ä½“
    const asteroidBelt = [
      { name: "ç¶ç¥æ˜Ÿ", type: "asteroid", distanceAU: 2.36, diameterKm: 525, orbitDays: 1325, radius: 1.4, color: "#CD853F", info: "å°è¡Œæ˜Ÿå¸¦ç¬¬äºŒäº®å¤©ä½“" },
      { name: "æ™ºç¥æ˜Ÿ", type: "asteroid", distanceAU: 2.77, diameterKm: 544, orbitDays: 1686, radius: 1.5, color: "#A0522D", info: "å°è¡Œæ˜Ÿå¸¦ç¬¬äºŒå¤§å¤©ä½“" },
      { name: "å¥ç¥æ˜Ÿ", type: "asteroid", distanceAU: 3.14, diameterKm: 430, orbitDays: 2031, radius: 1.3, color: "#8B4513", info: "å°è¡Œæ˜Ÿå¸¦ç¬¬å››å¤§å¤©ä½“" }
    ];
    // è‘—åå½—æ˜Ÿ
    const comets = [
      { 
        name: "å“ˆé›·å½—æ˜Ÿ", 
        type: "comet", 
        perihelionAU: 0.6, 
        aphelionAU: 35.1, 
        avgDistanceAU: 17.8, 
        orbitDays: 27990, 
        radius: 1.2, 
        color: "#87CEFA", 
        tail: false, // ç¦ç”¨å½—å°¾
        info: "æœ€è‘—åçš„å‘¨æœŸå½—æ˜Ÿï¼Œæ¯76å¹´å›å½’ä¸€æ¬¡"
      },
      { 
        name: "æµ·å°”-æ³¢æ™®å½—æ˜Ÿ", 
        type: "comet", 
        perihelionAU: 0.91, 
        aphelionAU: 370.8, 
        avgDistanceAU: 185.8, 
        orbitDays: 1017000, 
        radius: 1.8, 
        color: "#4682B4", 
        tail: false, // ç¦ç”¨å½—å°¾
        info: "1997å¹´å‡ºç°åœ¨å¤œç©ºä¸­çš„å¤§å½—æ˜Ÿ"
      },
      { 
        name: "ä¸˜ç•™è«å¤«-æ ¼æ‹‰è¥¿ç¼…ç§‘", 
        type: "comet", 
        perihelionAU: 1.24, 
        aphelionAU: 5.68, 
        avgDistanceAU: 3.46, 
        orbitDays: 2156, 
        radius: 0.8, 
        color: "#6A5ACD", 
        tail: false, // ç¦ç”¨å½—å°¾
        info: "ç½—å¡å¡”å·æ¢æµ‹å™¨ç™»é™†çš„å½—æ˜Ÿ"
      }
    ];
    // å¤ªç©ºæ¢æµ‹å™¨ - ä¿ç•™æ‚¨çš„æ·±è“è‰²ç³»ä¿®æ”¹
    const spaceProbes = [
      { 
        name: "æ—…è¡Œè€…1å·", 
        type: "probe", 
        distanceAU: 163, 
        radius: 1.5, 
        color: "#87ceeb",
        info: "äººç±»æœ€è¿œçš„äººé€ ç‰©ä½“ï¼ˆ1977å¹´å‘å°„ï¼‰",
        status: "å·²è¿›å…¥æ˜Ÿé™…ç©ºé—´",
        angle: Math.random() * Math.PI * 2
      },
      { 
        name: "æ—…è¡Œè€…2å·", 
        type: "probe", 
        distanceAU: 135, 
        radius: 1.5, 
        color: "#d4b1e0",
        info: "å”¯ä¸€è®¿é—®è¿‡å››å¤§å¤–è¡Œæ˜Ÿçš„æ¢æµ‹å™¨",
        status: "å·²è¿›å…¥æ˜Ÿé™…ç©ºé—´",
        angle: Math.random() * Math.PI * 2
      },
      { 
        name: "å…ˆé©±è€…10å·", 
        type: "probe", 
        distanceAU: 127, 
        radius: 1.3, 
        color: "#7255b2",
        info: "ç¬¬ä¸€ä¸ªç©¿è¶Šå°è¡Œæ˜Ÿå¸¦çš„äººé€ ç‰©ä½“",
        status: "ä¿¡å·å·²ä¸¢å¤±",
        angle: Math.random() * Math.PI * 2
      },
      { 
        name: "æ–°è§†é‡å·", 
        type: "probe", 
        distanceAU: 55, 
        radius: 1.4, 
        color: "#977dc6",
        info: "æ¢è®¿å†¥ç‹æ˜Ÿå’ŒæŸ¯ä¼Šä¼¯å¸¦å¤©ä½“çš„æ¢æµ‹å™¨",
        status: "æ­£åœ¨æ¢ç´¢æŸ¯ä¼Šä¼¯å¸¦",
        angle: Math.random() * Math.PI * 2
      }
    ];
    // è¿œæ–¹å¤©ä½“ï¼ˆå†…å¥¥å°”ç‰¹äº‘ï¼‰- æ·»åŠ äº†å››ä¸ªæ–°å¤©ä½“
    const distantObjects = [
      { 
        name: "èµ›å¾·å¨œ", 
        type: "distant", 
        perihelionAU: 76, 
        aphelionAU: 937, 
        avgDistanceAU: 506.5, 
        diameterKm: 995, 
        orbitDays: 4_170_000, 
        radius: 1.5, 
        color: "#FFA07A", 
        info: "å¯èƒ½å±äºå†…å¥¥å°”ç‰¹äº‘çš„é¥è¿œå¤©ä½“"
      },
      { 
        name: "2012 VPâ‚â‚â‚ƒ", 
        type: "distant", 
        perihelionAU: 80, 
        aphelionAU: 446, 
        avgDistanceAU: 263, 
        diameterKm: 450, 
        orbitDays: 1_610_000, 
        radius: 1.2, 
        color: "#FF7F50", 
        info: "å†…å¥¥å°”ç‰¹äº‘å€™é€‰å¤©ä½“"
      },
      { 
        name: "2015 TG387", 
        type: "distant", 
        perihelionAU: 65, 
        aphelionAU: 2300, 
        avgDistanceAU: 1182.5, 
        diameterKm: 300, 
        orbitDays: 1_500_000, 
        radius: 1.2, 
        color: "#FFA500", 
        info: "è½¨é“è¿œæ—¥ç‚¹æ¥è¿‘å¥¥å°”ç‰¹äº‘å†…ç¼˜çš„æç«¯æµ·ç‹æ˜Ÿå¤–å¤©ä½“"
      },
      { 
        name: "2013 SY99", 
        type: "distant", 
        perihelionAU: 50, 
        aphelionAU: 2000, 
        avgDistanceAU: 1025, 
        diameterKm: 250, 
        orbitDays: 1_200_000, 
        radius: 1.1, 
        color: "#DAA520", 
        info: "è½¨é“è¿œæ—¥ç‚¹æ¥è¿‘å¥¥å°”ç‰¹äº‘å†…ç¼˜çš„å¤©ä½“"
      },
      { 
        name: "2018 AG37", 
        type: "distant", 
        perihelionAU: 65, 
        aphelionAU: 1300, 
        avgDistanceAU: 682.5, 
        diameterKm: 400, 
        orbitDays: 800_000, 
        radius: 1.3, 
        color: "#9ACD32", 
        info: "è·ç¦»å¤ªé˜³æœ€è¿œçš„å·²çŸ¥å¤©ä½“ä¹‹ä¸€"
      },
      { 
        name: "2021 FD10", 
        type: "distant", 
        perihelionAU: 80, 
        aphelionAU: 1500, 
        avgDistanceAU: 790, 
        diameterKm: 350, 
        orbitDays: 900_000, 
        radius: 1.2, 
        color: "#6495ED", 
        info: "æ–°å‘ç°çš„å¥¥å°”ç‰¹äº‘å†…ç¼˜å¤©ä½“"
      }
    ];
    // æœˆçƒæ•°æ®
    const moon = {
      name: "æœˆçƒ",
      parent: "åœ°çƒ",
      orbitRadiusAU: 0.00257,
      orbitPeriodDays: 27.3,
      radius: 1.5,
      color: "#CCCCCC",
      visualScale: 12
    };
    // æŸ¯ä¼Šä¼¯å¸¦å°å¤©ä½“
    const kuiperBeltObjects = [];
    for (let i = 0; i < 300; i++) {
      const au = 30 + Math.random() * 25;
      const angle = Math.random() * Math.PI * 2;
      const visualR = auToVisual(au);
      kuiperBeltObjects.push({
        x: Math.cos(angle) * visualR,
        y: Math.sin(angle) * visualR
      });
    }
    // å¥¥å°”ç‰¹äº‘
    const oortCloudAU = 63000;
    const oortVisualR = auToVisual(oortCloudAU);
    // æ˜Ÿé™…åŒºåŸŸæ ‡æ³¨
    const interstellarRegions = [
      { name: "æ—¥çƒå±‚é¡¶", distanceAU: 120, color: "#ffb444", label: "å¤ªé˜³é£åœæ­¢å¤„" },
      { name: "å°è¡Œæ˜Ÿå¸¦", distanceAU: 2.8, color: "#B8860B", label: "å²©çŸ³å¤©ä½“èšé›†åŒº" },
      { name: "æŸ¯ä¼Šä¼¯å¸¦", distanceAU: 45, color: "#4682B4", label: "å†°è´¨å¤©ä½“å¸¦" },
      { name: "å¥¥å°”ç‰¹äº‘å†…ç¼˜", distanceAU: 2000, color: "#AAAAFF", label: "é•¿å‘¨æœŸå½—æ˜Ÿæ¥æº" },
      { name: "å¥¥å°”ç‰¹äº‘å¤–ç¼˜", distanceAU: 63000, color: "#e5b5c7", label: "å¤ªé˜³å¼•åŠ›ä¸»å¯¼è¾¹ç•Œ" }
    ];
    // æ ‡ç­¾é¿è®©ç³»ç»Ÿ - é‡å¤§å‡çº§
    const labelSystem = {
      labels: [],
      minDistance: 40,
      repulsion: 0.8,
      maxIterations: 15,
      verticalOffset: 30,
      init() {
        this.labels = [];
      },
      addLabel(x, y, text, group = 'default', type = 'default', verticalAdjust = 0, color = '#FFFFFF') {
        const width = ctx.measureText(text).width + 15;
        const height = 16;
        this.labels.push({
          x, 
          y: y + verticalAdjust * this.verticalOffset,
          text,
          width, 
          height,
          group,
          type,
          fixed: false,
          vx: 0,
          vy: 0,
          verticalAdjust,
          color
        });
      },
      update() {
        this.labels.forEach(label => {
          label.vx = 0;
          label.vy = 0;
        });
        for (let i = 0; i < this.labels.length; i++) {
          for (let j = i + 1; j < this.labels.length; j++) {
            const label1 = this.labels[i];
            const label2 = this.labels[j];
            if (label1.group !== label2.group) continue;
            const dx = label1.x - label2.x;
            const dy = label1.y - label2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < this.minDistance) {
              const force = (this.minDistance - distance) * this.repulsion * 1.5;
              const angle = Math.atan2(dy, dx);
              const fx = Math.cos(angle) * force;
              const fy = Math.sin(angle) * force;
              label1.vx += fx;
              label1.vy += fy;
              label2.vx -= fx;
              label2.vy -= fy;
            }
          }
        }
        this.labels.forEach(label => {
          if (!label.fixed) {
            label.x += label.vx * 0.8;
            label.y += label.vy * 0.8;
          }
        });
      },
      reset() {
        this.init();
      },
      draw() {
        // å…ˆç»˜åˆ¶AUæ•°å€¼æ ‡ç­¾
        this.labels
          .filter(label => label.type === 'au_value')
          .forEach(label => {
            ctx.fillStyle = 'rgba(200, 220, 255, 0.9)';
            ctx.font = '13px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(label.text, label.x, label.y);
          });
        // å†ç»˜åˆ¶åŒºåŸŸåç§°æ ‡ç­¾
        this.labels
          .filter(label => label.type === 'region_name')
          .forEach(label => {
            ctx.fillStyle = label.color || 'rgba(255, 255, 255, 0.95)';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label.text, label.x, label.y);
          });
        // æœ€åç»˜åˆ¶å¤©ä½“æ ‡ç­¾
        this.labels
          .filter(label => label.type === 'body_name')
          .forEach(label => {
            ctx.fillStyle = label.color;
            ctx.font = '13px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(label.text, label.x, label.y);
          });
      }
    };
    // è¾“å…¥å¤„ç†
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        spacePressed = true;
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        spacePressed = false;
      }
    });
    canvas.addEventListener('mousedown', (e) => {
      if (spacePressed && e.button === 0) {
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        canvas.style.cursor = 'grabbing';
      }
    });
    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      if (isDragging) {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        camX -= dx / zoom;
        camY -= dy / zoom;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
      }
    });
    window.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        canvas.style.cursor = spacePressed ? 'grab' : 'default';
      }
    });
    window.addEventListener('mouseleave', () => {
      isDragging = false;
      canvas.style.cursor = 'default';
    });
    canvas.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = zoom * zoomFactor;
        zoom = Math.min(Math.max(newZoom, 0.05), 15);
        const worldMouse = screenToWorld(mouseX, mouseY);
        const screenMouseAfter = worldToScreen(worldMouse.x, worldMouse.y);
        const dx = mouseX - screenMouseAfter.x;
        const dy = mouseY - screenMouseAfter.y;
        camX -= dx / zoom;
        camY -= dy / zoom;
      }
    });
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    // æš‚åœæŒ‰é’®
    pauseBtn.addEventListener('click', () => {
      isPaused = !isPaused;
      pauseBtn.textContent = isPaused ? 'â–¶ï¸ æ’­æ”¾' : 'â¸ï¸ æš‚åœ';
    });
    // æ˜¾ç¤ºæ§åˆ¶æŒ‰é’®
    document.querySelectorAll('.toggleBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.type;
        displayOptions[type] = !displayOptions[type];
        btn.classList.toggle('active', displayOptions[type]);
      });
    });
    let hoveredObject = null;
    let time = 0;
    const timeScale = 0.5;
    function checkHover(px, py, radius, obj) {
      const screen = worldToScreen(px, py);
      const dx = mouseX - screen.x;
      const dy = mouseY - screen.y;
      if (Math.sqrt(dx * dx + dy * dy) <= radius * 2) {
        hoveredObject = obj;
      }
    }
    function drawOrbit(visualRadius, color = 'rgba(255, 255, 255, 0.08)', dash = []) {
      const screenCenter = worldToScreen(0, 0);
      ctx.beginPath();
      ctx.arc(screenCenter.x, screenCenter.y, visualRadius * zoom, 0, Math.PI * 2);
      ctx.strokeStyle = color;
      ctx.setLineDash(dash);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    function drawAUAxis() {
      const ticks = [0.1, 0.4, 1, 5, 10, 30, 100, 1000, 10000, 63000];
      const screenCenter = worldToScreen(0, 0);
      labelSystem.reset();
      ticks.forEach(au => {
        const r = auToVisual(au);
        const screenR = r * zoom;
        if (screenR < 10 || screenR > 10000) return;
        ctx.beginPath();
        const x1 = screenCenter.x + screenR;
        const y1 = screenCenter.y;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x1 + 8, y1);
        ctx.strokeStyle = 'rgba(200, 220, 255, 0.5)';
        ctx.stroke();
        // åŠ¨æ€è°ƒæ•´å­—ä½“å¤§å°
        const fontSize = Math.max(10, Math.min(14, 180 / screenR));
        labelSystem.addLabel(
          x1 + 12, 
          y1 - 4, 
          `${au} AU`, 
          'interstellar',
          'au_value'
        );
      });
    }
    // è¡Œæ˜Ÿæ ‡ç­¾
    function drawBodyLabel(name, x, y, radius, verticalAdjust = 0, color = '#FFFFFF', group = 'planets') {
      const labelX = x + radius * 2.5 + 5;
      const labelY = y;
      labelSystem.addLabel(
        labelX, 
        labelY, 
        name, 
        group, 
        'body_name',
        verticalAdjust,
        color
      );
    }
    // æ˜Ÿé™…åŒºåŸŸæ ‡ç­¾
    function drawInterstellarRegionLabels() {
      // ç»˜åˆ¶æ‰€æœ‰æ˜Ÿé™…åŒºåŸŸçš„å®Œæ•´è™šçº¿åœˆ
      interstellarRegions.forEach((region, index) => {
        const r = auToVisual(region.distanceAU);
        const screenR = r * zoom;
        const screenCenter = worldToScreen(0, 0);
        // ç‰¹æ®Šå¤„ç†å°è¡Œæ˜Ÿå¸¦å’ŒæŸ¯ä¼Šä¼¯å¸¦ï¼Œä½¿ç”¨å¡«å……æ•ˆæœ
        if (region.name === "å°è¡Œæ˜Ÿå¸¦") {
          ctx.beginPath();
          ctx.arc(screenCenter.x, screenCenter.y, screenR * 0.8, 0, Math.PI * 2);
          ctx.arc(screenCenter.x, screenCenter.y, screenR * 1.2, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(184, 134, 11, 0.05)';
          ctx.fill();
        } else if (region.name === "æŸ¯ä¼Šä¼¯å¸¦") {
          ctx.beginPath();
          ctx.arc(screenCenter.x, screenCenter.y, screenR * 0.8, 0, Math.PI * 2);
          ctx.arc(screenCenter.x, screenCenter.y, screenR * 1.2, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(70, 130, 180, 0.05)';
          ctx.fill();
        }
        // ç»˜åˆ¶è¾¹ç•Œ
        ctx.beginPath();
        ctx.arc(screenCenter.x, screenCenter.y, screenR, 0, Math.PI * 2);
        ctx.strokeStyle = region.color;
        ctx.setLineDash([(region.name === "æ—¥çƒå±‚é¡¶") ? 3 : 5, (region.name === "æ—¥çƒå±‚é¡¶") ? 5 : 10]);
        ctx.stroke();
        ctx.setLineDash([]);
        // æ™ºèƒ½é”™ä½ï¼šä¸ºå¥¥å°”ç‰¹äº‘å¤–ç¼˜è®¾ç½®ç‰¹æ®Šä½ç½®
        let verticalAdjust = 0;
        if (region.name === "å¥¥å°”ç‰¹äº‘å¤–ç¼˜") {
          verticalAdjust = 2.5; // è°ƒæ•´åˆ°æ›´é ä¸Šä½ç½®
        } else if (region.name === "å¥¥å°”ç‰¹äº‘å†…ç¼˜") {
          verticalAdjust = 1.5;
        } else if (region.name === "æŸ¯ä¼Šä¼¯å¸¦") {
          verticalAdjust = -1.5;
        } else if (region.name === "å°è¡Œæ˜Ÿå¸¦") {
          verticalAdjust = -0.5;
        } else {
          verticalAdjust = (index % 2 === 0) ? 0.5 : -0.5;
        }
        labelSystem.addLabel(
          screenCenter.x + screenR,
          screenCenter.y + verticalAdjust * 25, 
          region.name,
          'interstellar',
          'region_name',
          0,
          region.color
        );
      });
      for (let i = 0; i < labelSystem.maxIterations; i++) {
        labelSystem.update();
      }
    }
    function animate() {
      // æ¸…é™¤ç”»å¸ƒ
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // ç»˜åˆ¶æ˜Ÿç©º
      drawStars();
      hoveredObject = null;
      // è·å–å¤ªé˜³ä½ç½®
      const sunScreen = worldToScreen(0, 0);
      // ç»˜åˆ¶å¥¥å°”ç‰¹äº‘
      const oortScreenR = oortVisualR * zoom;
      ctx.beginPath();
      ctx.arc(sunScreen.x, sunScreen.y, oortScreenR, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(180, 150, 255, 0.1)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 15]);
      ctx.stroke();
      ctx.setLineDash([]);
      // ç»˜åˆ¶AUæ ‡å°º
      drawAUAxis();
      // ç»˜åˆ¶æ˜Ÿé™…åŒºåŸŸæ ‡ç­¾
      drawInterstellarRegionLabels();
      // ç»˜åˆ¶æŸ¯ä¼Šä¼¯å¸¦å°å¤©ä½“
      ctx.fillStyle = 'rgba(180, 200, 255, 0.3)';
      kuiperBeltObjects.forEach(obj => {
        const s = worldToScreen(obj.x, obj.y);
        if (s.x > -50 && s.x < canvas.width + 50 && s.y > -50 && s.y < canvas.height + 50) {
          ctx.beginPath();
          ctx.arc(s.x, s.y, 0.8, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      // ç»˜åˆ¶å¤©ä½“è½¨é“
      // 1. å…«å¤§è¡Œæ˜Ÿå’Œå†¥ç‹æ˜Ÿ
      celestialBodies.forEach((body, i) => {
        if (body.distanceAU > 0) {
          drawOrbit(auToVisual(body.distanceAU));
        }
      });
      // 2. æŸ¯ä¼Šä¼¯å¸¦çŸ®è¡Œæ˜Ÿ
      if (displayOptions.dwarfPlanets) {
        dwarfPlanets.forEach(planet => {
          drawOrbit(auToVisual(planet.distanceAU), 'rgba(255, 255, 255, 0.05)', [5, 5]);
        });
      }
      // 3. å°è¡Œæ˜Ÿå¸¦
      if (displayOptions.asteroidBelt) {
        asteroidBelt.forEach(asteroid => {
          drawOrbit(auToVisual(asteroid.distanceAU), 'rgba(210, 180, 140, 0.1)', [3, 3]);
        });
      }
      // 4. å½—æ˜Ÿ - å·²ç§»é™¤è½¨é“ç»˜åˆ¶
      // 5. å¤ªç©ºæ¢æµ‹å™¨
      if (displayOptions.probes) {
        spaceProbes.forEach(probe => {
          // æ·»åŠ æå…¶ç¼“æ…¢çš„ç§»åŠ¨
          const slowFactor = 0.0001; // æ¯å¸§ç§»åŠ¨æå°è§’åº¦
          const angle = probe.angle + (time * slowFactor);
          const visualR = auToVisual(probe.distanceAU);
          const wx = Math.cos(angle) * visualR;
          const wy = Math.sin(angle) * visualR;
          const s = worldToScreen(wx, wy);
          const r = probe.radius * zoom;
          // ç»˜åˆ¶æ¢æµ‹å™¨
          ctx.beginPath();
          ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
          ctx.fillStyle = probe.color;
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 1;
          ctx.fill();
          ctx.stroke();
          checkHover(wx, wy, r * 2, probe);
          // æ·»åŠ æ ‡ç­¾
          drawBodyLabel(probe.name, s.x, s.y, r, 0, probe.color, 'probes');
        });
      }
      // 6. è¿œæ–¹å¤©ä½“
      /*
      if (displayOptions.distantObjects) {
        distantObjects.forEach(obj => {
          drawOrbit(auToVisual(obj.avgDistanceAU), obj.color, [2, 10]);
        });
      }
      */
      // ç»˜åˆ¶å¤ªé˜³
      ctx.beginPath();
      ctx.arc(sunScreen.x, sunScreen.y, celestialBodies[0].radius * zoom, 0, Math.PI * 2);
      ctx.fillStyle = celestialBodies[0].color;
      ctx.shadowColor = celestialBodies[0].color;
      ctx.shadowBlur = 20 * zoom;
      ctx.fill();
      ctx.shadowBlur = 0;
       ctx.shadowBlur = 0;
      checkHover(0, 0, celestialBodies[0].radius, celestialBodies[0]);
      // ç»˜åˆ¶è¡Œæ˜Ÿ
      for (let i = 1; i < celestialBodies.length; i++) {
        const body = celestialBodies[i];
        // è·³è¿‡ä¸åº”æ˜¾ç¤ºçš„å¤©ä½“
        if (body.group && !displayOptions[body.group]) continue;
        const angle = (time / body.orbitDays) * Math.PI * 2;
        const visualR = auToVisual(body.distanceAU);
        const wx = Math.cos(angle) * visualR;
        const wy = Math.sin(angle) * visualR;
        const s = worldToScreen(wx, wy);
        const r = body.radius * zoom;
        // ç‰¹æ®Šæ•ˆæœï¼šåœŸæ˜Ÿç¯
        if (body.hasRings) {
          ctx.beginPath();
          ctx.ellipse(s.x, s.y, r * 2.2, r * 0.5, 0, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(227, 224, 192, 0.8)';
          ctx.lineWidth = r * 0.2;
          ctx.stroke();
        }
        // ç»˜åˆ¶è¡Œæ˜Ÿ
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fillStyle = body.color;
        ctx.fill();
        // åœ°çƒ + æœˆçƒ
        if (body.hasMoon) {
          const moonAngle = (time / moon.orbitPeriodDays) * Math.PI * 2;
          const moonVisualR = auToVisual(moon.orbitRadiusAU) * moon.visualScale;
          const moonWX = wx + Math.cos(moonAngle) * moonVisualR;
          const moonWY = wy + Math.sin(moonAngle) * moonVisualR;
          const moonS = worldToScreen(moonWX, moonWY);
          const moonR = moon.radius * zoom;
          // ç»˜åˆ¶è½¨é“
          ctx.beginPath();
          ctx.arc(s.x, s.y, moonVisualR * zoom, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(200, 200, 200, 0.2)';
          ctx.stroke();
          // ç»˜åˆ¶æœˆçƒ
          ctx.beginPath();
          ctx.arc(moonS.x, moonS.y, moonR, 0, Math.PI * 2);
          ctx.fillStyle = moon.color;
          ctx.fill();
          // æœˆçƒæ ‡ç­¾
          drawBodyLabel("æœˆçƒ", moonS.x, moonS.y, moonR, 0.5, '#CCCCCC', 'moons');
          // æ‚¬åœæ£€æµ‹
          checkHover(moonWX, moonWY, moonR, {
            name: "æœˆçƒ",
            info: "åœ°çƒçš„å¤©ç„¶å«æ˜Ÿ",
            distanceAU: moon.orbitRadiusAU,
            distanceKm: (moon.orbitRadiusAU * 1.5e8).toFixed(0)
          });
        }
        checkHover(wx, wy, r, body);
        // æ·»åŠ æ ‡ç­¾
        drawBodyLabel(body.name, s.x, s.y, r, 0, body.color);
      }
      // ç»˜åˆ¶æŸ¯ä¼Šä¼¯å¸¦çŸ®è¡Œæ˜Ÿ
      if (displayOptions.dwarfPlanets) {
        dwarfPlanets.forEach(planet => {
          const angle = (time / planet.orbitDays) * Math.PI * 2;
          const visualR = auToVisual(planet.distanceAU);
          const wx = Math.cos(angle) * visualR;
          const wy = Math.sin(angle) * visualR;
          const s = worldToScreen(wx, wy);
          const r = planet.radius * zoom;
          // ç»˜åˆ¶çŸ®è¡Œæ˜Ÿ
          ctx.beginPath();
          ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
          ctx.fillStyle = planet.color;
          ctx.fill();
          checkHover(wx, wy, r, planet);
          // æ·»åŠ æ ‡ç­¾
          drawBodyLabel(planet.name, s.x, s.y, r, 0, planet.color, 'dwarfPlanets');
        });
      }
      // ç»˜åˆ¶å°è¡Œæ˜Ÿå¸¦å¤©ä½“
      if (displayOptions.asteroidBelt) {
        asteroidBelt.forEach(asteroid => {
          const angle = (time / asteroid.orbitDays) * Math.PI * 2;
          const visualR = auToVisual(asteroid.distanceAU);
          const wx = Math.cos(angle) * visualR;
          const wy = Math.sin(angle) * visualR;
          const s = worldToScreen(wx, wy);
          const r = asteroid.radius * zoom;
          // ç»˜åˆ¶å°è¡Œæ˜Ÿ
          ctx.beginPath();
          ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
          ctx.fillStyle = asteroid.color;
          ctx.fill();
          checkHover(wx, wy, r, asteroid);
          // æ·»åŠ æ ‡ç­¾
          drawBodyLabel(asteroid.name, s.x, s.y, r, 0, asteroid.color, 'asteroidBelt');
        });
      }
      // ç»˜åˆ¶å½—æ˜Ÿ - æ— è½¨é“ï¼Œæ— å½—å°¾
      if (displayOptions.comets) {
        comets.forEach(comet => {
          const angle = (time / comet.orbitDays) * Math.PI * 2;
          const visualR = auToVisual(comet.avgDistanceAU);
          const wx = Math.cos(angle) * visualR;
          const wy = Math.sin(angle) * visualR;
          const s = worldToScreen(wx, wy);
          const r = comet.radius * zoom;
          // ä»…ç»˜åˆ¶å½—æ˜Ÿå¤´éƒ¨
          ctx.beginPath();
          ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
          ctx.fillStyle = comet.color;
          ctx.fill();
          checkHover(wx, wy, r * 2, comet);
          // æ·»åŠ æ ‡ç­¾
          drawBodyLabel(comet.name, s.x, s.y, r, 0, comet.color, 'comets');
        });
      }
      // ç»˜åˆ¶è¿œæ–¹å¤©ä½“
      if (displayOptions.distantObjects) {
        distantObjects.forEach(obj => {
          const angle = (time / obj.orbitDays * 0.01) * Math.PI * 2; // ææ…¢çš„ç§»åŠ¨
          const visualR = auToVisual(obj.avgDistanceAU);
          const wx = Math.cos(angle) * visualR;
          const wy = Math.sin(angle) * visualR;
          const s = worldToScreen(wx, wy);
          const r = obj.radius * zoom;
          // ç»˜åˆ¶å¤©ä½“
          ctx.beginPath();
          ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
          ctx.fillStyle = obj.color;
          ctx.fill();
          checkHover(wx, wy, r * 2, obj);
          // æ·»åŠ æ ‡ç­¾
          drawBodyLabel(obj.name, s.x, s.y, r, 0, obj.color, 'distantObjects');
        });
      }
      // æ›´æ–°å’Œç»˜åˆ¶æ ‡ç­¾
      for (let i = 0; i < labelSystem.maxIterations; i++) {
        labelSystem.update();
      }
      labelSystem.draw();
      // ä¿¡æ¯é¢æ¿
      if (hoveredObject) {
        infoPanel.style.display = 'block';
        let html = `<h3>${hoveredObject.name}`;
        if (hoveredObject.type === 'dwarf') html += 'ï¼ˆçŸ®è¡Œæ˜Ÿï¼‰';
        else if (hoveredObject.type === 'star') html += 'ï¼ˆæ’æ˜Ÿï¼‰';
        else if (hoveredObject.type === 'asteroid') html += 'ï¼ˆå°è¡Œæ˜Ÿï¼‰';
        else if (hoveredObject.type === 'comet') html += 'ï¼ˆå½—æ˜Ÿï¼‰';
        else if (hoveredObject.type === 'probe') html += 'ï¼ˆå¤ªç©ºæ¢æµ‹å™¨ï¼‰';
        else if (hoveredObject.type === 'distant') html += 'ï¼ˆè¿œæ–¹å¤©ä½“ï¼‰';
        html += `</h3>`;
        if (hoveredObject.distanceAU > 0) {
          html += `<p>â˜€ï¸ è·å¤ªé˜³ï¼š${hoveredObject.distanceAU.toFixed(1)} AU<br>ï¼ˆ${(hoveredObject.distanceAU * 1.5e8).toLocaleString()} å…¬é‡Œï¼‰</p>`;
        } else if (hoveredObject.perihelionAU && hoveredObject.aphelionAU) {
          html += `<p>â˜„ï¸ è½¨é“ï¼šè¿‘æ—¥ç‚¹ ${hoveredObject.perihelionAU} AU, è¿œæ—¥ç‚¹ ${hoveredObject.aphelionAU} AU</p>`;
        }
        if (hoveredObject.diameterKm) {
          html += `<p>ğŸ“ ç›´å¾„ï¼š${hoveredObject.diameterKm.toLocaleString()} å…¬é‡Œ</p>`;
        }
        if (hoveredObject.orbitDays > 0 && hoveredObject.orbitDays < 100000) {
          html += `<p>â³ å…¬è½¬å‘¨æœŸï¼š${Math.round(hoveredObject.orbitDays)} åœ°çƒæ—¥</p>`;
        } else if (hoveredObject.orbitDays > 0) {
          html += `<p>â³ å…¬è½¬å‘¨æœŸï¼š${(hoveredObject.orbitDays/365.25).toFixed(1)} åœ°çƒå¹´</p>`;
        }
        if (hoveredObject.rotationHours !== undefined) {
          const hrs = Math.abs(hoveredObject.rotationHours);
          const days = (hrs / 24).toFixed(2);
          const dir = hoveredObject.rotationHours < 0 ? 'ï¼ˆé€†è¡Œï¼‰' : '';
          html += `<p>ğŸ”„ è‡ªè½¬å‘¨æœŸï¼š${days} åœ°çƒæ—¥${dir}</p>`;
        }
        if (hoveredObject.status) {
          html += `<p>ğŸ“¡ çŠ¶æ€ï¼š${hoveredObject.status}</p>`;
        }
        if (hoveredObject.info) {
          html += `<p>â„¹ï¸ ${hoveredObject.info}</p>`;
        }
        infoPanel.innerHTML = html;
      } else {
        infoPanel.style.display = 'none';
      }
      // å…‰æ ‡
      if (spacePressed) {
        canvas.style.cursor = isDragging ? 'grabbing' : 'grab';
      } else {
        canvas.style.cursor = 'default';
      }
      if (!isPaused) {
        time += timeScale;
      }
      requestAnimationFrame(animate);
    }
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initStars();
    });
    initStars();
    animate();
  </script>
</body>
</html>